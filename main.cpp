#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <PControl.h>
#include <PAck.h>

//Basic client hard reset v2 packet
unsigned char hardresetclientv2[] = 
{
  0x00, 0x0e, 0x38, 0x04, 0x6c, 0x44, 0xbd, 0x10,
  0xce, 0xe3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00
};

//P_ACK base packet, assuming no packet loss this confirmation is only ever
//for a single packet, therefore only the last 12 bytes need to be changed
//to include 1, which packet is being ack'd, and two, the remote session ID
// for this session
unsigned char ack[] = 
{
  0x00, 0x16, 0x28, 0x04, 0x6c, 0x44, 0xbd, 0x10,
  0xce, 0xe3, 0x98, 0x01, 0x00, 0x00, 0x00, 0x00,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

unsigned char TLS_hello[] = 
{
  0x16, 0x03, 0x01, 0x01, 0x28, 0x01, 0x00, 0x01,
  0x24, 0x03, 0x03, 0xe2, 0x65, 0xee, 0xce, 0x8a,
  0x5b, 0xe0, 0x17, 0xc5, 0x37, 0x78, 0xdc, 0x76,
  0x6b, 0xcd, 0x5b, 0x81, 0x52, 0xf2, 0xa8, 0xa9,
  0x50, 0xcc, 0xc9, 0xe1, 0x18, 0x78, 0xa0, 0x7a,
  0x24, 0x80, 0x01, 0x00, 0x00, 0xaa, 0xc0, 0x30,
  0xc0, 0x2c, 0xc0, 0x28, 0xc0, 0x24, 0xc0, 0x14,
  0xc0, 0x0a, 0x00, 0xa5, 0x00, 0xa3, 0x00, 0xa1,
  0x00, 0x9f, 0x00, 0x6b, 0x00, 0x6a, 0x00, 0x69,
  0x00, 0x68, 0x00, 0x39, 0x00, 0x38, 0x00, 0x37,
  0x00, 0x36, 0x00, 0x88, 0x00, 0x87, 0x00, 0x86,
  0x00, 0x85, 0xc0, 0x32, 0xc0, 0x2e, 0xc0, 0x2a,
  0xc0, 0x26, 0xc0, 0x0f, 0xc0, 0x05, 0x00, 0x9d,
  0x00, 0x3d, 0x00, 0x35, 0x00, 0x84, 0xc0, 0x2f,
  0xc0, 0x2b, 0xc0, 0x27, 0xc0, 0x23, 0xc0, 0x13,
  0xc0, 0x09, 0x00, 0xa4, 0x00, 0xa2, 0x00, 0xa0,
  0x00, 0x9e, 0x00, 0x67, 0x00, 0x40, 0x00, 0x3f,
  0x00, 0x3e, 0x00, 0x33, 0x00, 0x32, 0x00, 0x31,
  0x00, 0x30, 0x00, 0x9a, 0x00, 0x99, 0x00, 0x98,
  0x00, 0x97, 0x00, 0x45, 0x00, 0x44, 0x00, 0x43,
  0x00, 0x42, 0xc0, 0x31, 0xc0, 0x2d, 0xc0, 0x29,
  0xc0, 0x25, 0xc0, 0x0e, 0xc0, 0x04, 0x00, 0x9c,
  0x00, 0x3c, 0x00, 0x2f, 0x00, 0x96, 0x00, 0x41,
  0xc0, 0x11, 0xc0, 0x07, 0xc0, 0x0c, 0xc0, 0x02,
  0x00, 0x05, 0x00, 0x04, 0xc0, 0x12, 0xc0, 0x08,
  0x00, 0x16, 0x00, 0x13, 0x00, 0x10, 0x00, 0x0d,
  0xc0, 0x0d, 0xc0, 0x03, 0x00, 0x0a, 0x00, 0xff,
  0x01, 0x00, 0x00, 0x51, 0x00, 0x0b, 0x00, 0x04,
  0x03, 0x00, 0x01, 0x02, 0x00, 0x0a, 0x00, 0x1c,
  0x00, 0x1a, 0x00, 0x17, 0x00, 0x19, 0x00, 0x1c,
  0x00, 0x1b, 0x00, 0x18, 0x00, 0x1a, 0x00, 0x16,
  0x00, 0x0e, 0x00, 0x0d, 0x00, 0x0b, 0x00, 0x0c,
  0x00, 0x09, 0x00, 0x0a, 0x00, 0x0d, 0x00, 0x20,
  0x00, 0x1e, 0x06, 0x01, 0x06, 0x02, 0x06, 0x03,
  0x05, 0x01, 0x05, 0x02, 0x05, 0x03, 0x04, 0x01,
  0x04, 0x02, 0x04, 0x03, 0x03, 0x01, 0x03, 0x02,
  0x03, 0x03, 0x02, 0x01, 0x02, 0x02, 0x02, 0x03,
  0x00, 0x0f, 0x00, 0x01, 0x01
};

void print_error(const char *msg)
{
	printf(msg);
	exit(-1);
}

void fuzzHardReset()
{
	int sock;
	struct sockaddr_in server;
	unsigned char reply[500], serverID[8];

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0)
		print_error("Socket failed\n");
	printf("Socket created.\n");

	server.sin_addr.s_addr = inet_addr("192.168.1.105");
	server.sin_family = AF_INET;
	server.sin_port = htons(443);

	if(connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0)
		print_error("Connection failed\n");
	printf("Connected to server.\n");
		printf("Creating hard reset client packet:\n");
	PControl *hardreset = new PControl(hardresetclientv2);
	
	//Change the contents of the hard reset message
	hardreset->setOPcode((short)4);
	hardreset->setTLSPayload(TLS_hello, 301);
	hardreset->setLength((short)315);
	
	unsigned char buffer[500];
	hardreset->toPacket(buffer);
	
	if(send(sock, buffer, hardreset->packetSize(), 0) < 0)
		print_error("reset failed\n");

	if(recv(sock, reply, 500, 0) < 0)
		print_error("Receive failed\n");

	printf("Reading server response:\n");
	PControl *response = new PControl(reply);
}

void happyFlow()
{
	int sock;
	struct sockaddr_in server;
	unsigned char reply[500], serverID[8];

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0)
		print_error("Socket failed\n");
	printf("Socket created.\n");

	server.sin_addr.s_addr = inet_addr("192.168.1.105");
	server.sin_family = AF_INET;
	server.sin_port = htons(443);

	if(connect(sock, (struct sockaddr *)&server, sizeof(server)) < 0)
		print_error("Connection failed\n");
	printf("Connected to server.\n");
	
	//send the initial client reset request
	printf("Creating hard reset client packet:\n");
	PControl *hardreset = new PControl(hardresetclientv2);

	unsigned char buffer[500];
	hardreset->toPacket(buffer);
	
	if(send(sock, buffer, hardreset->packetSize(), 0) < 0)
		print_error("reset failed\n");

	if(recv(sock, reply, 500, 0) < 0)
		print_error("Receive failed\n");
	
	//extract the server session ID
	printf("Reading server response:\n");
	PControl *response = new PControl(reply);
	printf("Remote ID: %llu\n", response->getLocalSessionID());
	
	printf("Creating client ACK response:\n");
	PAck *firstAck = new PAck(ack);
	firstAck->setRemoteSessionID(response->getLocalSessionID());
	
	firstAck->toPacket(buffer);
	
	if(send(sock, buffer, firstAck->packetSize(), 0) < 0)
		print_error("first ack failed\n");
	
	//After this the TLS session should start
	
	close(sock);
	printf("\nDone.\n");
}

int main(int argc, char **argv)
{
	happyFlow();
	
	return 0;
}
